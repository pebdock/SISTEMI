──────────────────────────────────────────────────────────────────────────────
INDICE (nell’ordine del file Comandi.txt)
1) strace
2) pwd
3) Shell expansions (history / brace / tilde / parameter / arithmetic / command subst / quoting / word splitting / pathname / quote removal)
4) PATH
5) Utenti, gruppi, permessi + chown/chgrp/chmod
6) ls
7) Shebang
8) Variabili (locali/ambiente) + export/set/unset
9) source / man
10) Tipi di shell (login/non-login, interattiva/non)
11) Separatore ;  + autocompletamento TAB
12) Espressioni condizionali: [[ ]] vs [ ]/test
13) find
14) Riferimento indiretto: ${!var}
15) Exit status
16) Cicli/if + operatori ; || &&
17) File descriptor (FD)
18) read
19) exec (apertura/chiusura FD)
20) Redirezioni e pipe
21) wc
22) Processi, job control, segnali, kill/killall/nohup/disown, trap
23) Coreutils (sed, tail, head, tee, cut, grep, tr)
24) Parameter expansion (riassunto operativo)
25) Scaricamento con wget
26) tar
27) REGEX
28) dettagli while

──────────────────────────────────────────────────────────────────────────────
1) strace [comando]
• A cosa serve: visualizzare le system call invocate da un programma fino alla terminazione.
• Uso tipico: debug (“quali file tenta di aprire?”, “dove si blocca?”).
Esempi:
  strace ls
  strace -o trace.txt nome_programma arg1 arg2

──────────────────────────────────────────────────────────────────────────────
2) pwd
• Stampa il percorso assoluto della directory corrente (da / alla directory attuale).

──────────────────────────────────────────────────────────────────────────────
3) Shell expansions (espansioni della shell)

Ordine (utile per capire “cosa succede prima”):
  1) history expansion
  2) brace expansion
  3) tilde expansion
  4) parameter/variable expansion
  5) arithmetic expansion
  6) command substitution
  7) word splitting (se non quotato)
  8) pathname expansion (globbing)
  9) quote removal

3.1) History expansion
• history                → mostra cronologia numerata
• !N                     → esegue il comando numero N
• !stringa               → esegue l’ultimo comando che inizia con “stringa”
Nota: spesso è disabilitata di default in contesti non interattivi.

3.2) Brace expansion
• Genera stringhe “a partire da uno schema”:
  echo a{bu,ba,be}   → abu aba abe
• Niente spazi non protetti dentro { }.
• Sequenze:
  echo {1..6}        → 1 2 3 4 5 6
  echo {b..k}        → b c d e f g h i j k
• Annidamento:
  echo a{b,c{1,2}}   → ab ac1 ac2

3.3) Tilde expansion
• ~/dir          → home dell’utente corrente + /dir
• ~username      → home di “username”

3.4) Parameter and variable expansion
• $1, $2, ...     → argomenti posizionali dello script/comando
• $#              → numero argomenti
• $*              → tutti gli argomenti “in una sola stringa” (attenzione agli spazi)
• $@              → tutti gli argomenti; se quotato (“$@”) preserva ogni argomento separatamente
• $?              → exit status dell’ultimo comando
• $!              → PID dell’ultimo processo lanciato in background (con &)
• ${var}          → forma esplicita (utile per evitare ambiguità: ${var}X)
• ${#var}         → lunghezza (in caratteri/byte a seconda del contesto/locale)
• ${!var}         → espansione indiretta: se var contiene il nome di un’altra variabile, ${!var} restituisce il valore di quella variabile.
  Esempio:
    a="X"
    X="ciao"
    echo "${!a}"    -> ciao

3.5) Arithmetic expansion
• $(( ... ))  → ARITHMETIC EXPANSION (produce un valore)
  - Valuta l’espressione e la sostituisce con il risultato.
  - Si usa quando ti serve un numero “stampabile” o da assegnare.
  Esempi:
    echo $((3+4))          -> 7
    x=$((i+1))             # assegna il risultato a x
    echo "tot=$((a*b))"
• (( ... ))   → ARITHMETIC EVALUATION (è un comando, ritorna exit status)
  - Valuta l’espressione come comando.
  - Exit status: 0 se l’espressione è “vera” (risultato != 0), 1 se “falsa” (risultato == 0).
  - Si usa per condizioni in if/while e per incrementi/decrementi.
  Esempi:
    if (( i < 10 )); then echo ok; fi
    while (( i < 10 )); do ((i++)); done
    ((sum += x))           # aggiornamento variabile senza dover usare $((...))

Nota pratica
• Per test numerici: preferisci ((...)) invece di [[ ... -lt ... ]].
• $((...)) è utile quando devi inserire il risultato dentro una stringa o in un’assegnazione.

3.6) Command substitution
• $(comando)      → command substitution: esegue comando e sostituisce l’espressione con il suo stdout (in genere senza newline finali). È la forma consigliata perché è più leggibile e annidabile.
  Esempio:
    echo "oggi: $(date)"
• `comando`       → stessa cosa (stdout del comando), ma sintassi vecchia: annidare è scomodo e richiede escaping di `\``.
  Esempio:
    echo "oggi: `date`"


3.7) Quoting
• "..."  (double quotes)
  - impedisce globbing e separazione su spazi (word splitting) sul contenuto espanso
  - MA permette espansioni ($VAR, $(...), ecc.)
• '...'  (single quotes)
  - tutto letterale: niente espansioni
• $'...' (ANSI-C quoting)
  - supporta escape tipo \n, \t, \xHH, ecc.
Esempio:
  echo $'riga1\nriga2'

3.8) Word splitting
• IFS (Internal Field Separator) definisce i separatori usati nello split dopo espansioni non quotate.
• Default: spazio, tab, newline.
Tip: se devi preservare spazi iniziali in una read, spesso si usa:
  IFS= read -r linea

3.9) Pathname expansion (globbing)
• *        → qualunque sequenza (anche vuota)
• ?        → esattamente un carattere
• [abc]    → un carattere tra a/b/c
• [1-6]    → un carattere nell’intervallo
• [[:digit:]] [[:upper:]] [[:lower:]] … → classi POSIX

3.10) Quote removal
• Ultima fase: le virgolette usate per proteggere vengono rimosse.

──────────────────────────────────────────────────────────────────────────────
4) PATH
• Variabile d’ambiente che contiene le directory in cui bash cerca gli eseguibili.
• È una lista separata da “:” (es. /usr/bin:/bin:...).

──────────────────────────────────────────────────────────────────────────────
5) Utenti, gruppi, permessi + chown/chgrp/chmod

Concetti base
• Ogni utente ha: username + userID (UID)
• Ogni gruppo ha: groupname + groupID (GID)
• Un utente ha un gruppo primario e può appartenere a gruppi secondari.
• Ogni file/directory ha un proprietario (UID) e un gruppo (GID).

5.1) chown — cambia proprietario (e opzionalmente gruppo)
  chown nuovo_utente file
  chown utente:gruppo file

5.2) chgrp — cambia gruppo
  chgrp nuovo_gruppo file

5.3) chmod — cambia permessi
• r=4, w=2, x=1. Forma ottale: chmod 755 file
  - user: 7 = rwx
  - group: 5 = r-x
  - others: 5 = r-x
• Bit speciali (permessi “extra”)
  - setuid (4000): su un file eseguibile, il processo parte con l’UID del proprietario del file (non dell’utente che lo lancia). In ls appare “s” al posto della x dell’utente: -rwsr-xr-x.
  - setgid (2000): su un file eseguibile, il processo parte con il GID del gruppo del file; su una directory, i file/dir creati dentro ereditano il gruppo della directory. In ls appare “s” al posto della x del gruppo: -rwxr-sr-x (o drwxr-s---).
  - sticky (1000): su una directory, solo il proprietario del file (o root) può cancellare/rinominare file dentro, anche se la directory è scrivibile da tutti. In ls appare “t” al posto della x degli others: drwxrwxrwt (es. /tmp).

──────────────────────────────────────────────────────────────────────────────
6) ls
• Lista file in una directory. Opzioni utili (vedi ls --help):
  -l (dettagli), -a (nascosti), -h (dimensioni leggibili), ecc.

──────────────────────────────────────────────────────────────────────────────
7) Shebang
• All’inizio di uno script:
  #!/bin/bash
→ indica l’interprete da usare.

──────────────────────────────────────────────────────────────────────────────
8) Variabili: locali vs d’ambiente + export/set/unset

• Variabili locali: visibili solo nella shell corrente.
• Variabili d’ambiente: ereditate dai processi figli.

Comandi:
• export VAR=...        → rende VAR d’ambiente
• export -n VAR         → rimuove “export” (torna locale)
• set                   → mostra variabili e funzioni bash
  - set -o history / set +o history → abilita/disabilita history
  - set -a / set +a                → auto-export delle variabili create dopo
• unset VAR             → elimina la variabile

──────────────────────────────────────────────────────────────────────────────
9) source / man
• source script.sh   oppure   . script.sh
  → esegue lo script nella shell corrente (senza subshell)
• man comando
  → manuale del comando (opzioni, esempi, descrizione)

──────────────────────────────────────────────────────────────────────────────
10) Tipi di shell (avvio)

• Shell non interattiva lanciata con -c [stringa/script]
  - in queste note: “non analizza alcun file prima di avviarsi”
• Shell interattiva non di login (tipico terminale grafico)
  - legge ~/.bashrc
• Shell interattiva di login (ssh o bash -l/--login)
  - legge /etc/profile
  - poi il primo tra ~/.bash_profile, ~/.bash_login, ~/.profile
  - poi (spesso) ~/.bashrc

──────────────────────────────────────────────────────────────────────────────
11) ;  e autocompletamento TAB
• ; separa comandi in sequenza:
  comando1 ; comando2
• TAB: autocompletamento.

──────────────────────────────────────────────────────────────────────────────
12) Espressioni condizionali: [[ ]] vs [ ] / test

Dove si usano:
  if CONDIZIONE; then ...; fi

12.1) [[ ... ]] (Bash)
• Più comoda per comporre condizioni:
  - supporta &&, ||, ! e parentesi ( )
  - consente pattern matching (es. [[ $x == a* ]])

12.2) [ ... ] e test (stile POSIX)
• Operatori logici “storici”:
  -a (AND), -o (OR)
• Limitazioni tipiche:
  - parentesi per raggruppare vanno “escape-ate” (\(  \))
  - spesso serve \ per andare a capo

Confronti (promemoria)
• Aritmetici: -eq -ne -lt -le -gt -ge
• Stringhe:
  -z (lunghezza 0), -n (lunghezza !=0), ==, !=
  < > (ordine lessicografico: in [ ] vanno spesso escape-ati)
• File:
  -d (directory), -e (esiste), -f (file regolare), -h/-L (symlink),
  -r (readable), -w (writable), -x (executable), -s (size > 0),
  -t (vero se FD è aperto su terminale),
  -O (owner = effective uid), -G (group = effective gid),
  -nt (più recente), -ot (più vecchio)

──────────────────────────────────────────────────────────────────────────────
13) find
• Ricerca file/directory. Per opzioni ed esempi: find --help (o man find).
  SE METTO exec ricordare che per finire i comandi su usa \;
──────────────────────────────────────────────────────────────────────────────
14) Riferimento indiretto: ${!nomevar}
Esempio:
  varA=bubu
  varB=varA
  echo "${!varB}"   # stampa: bubu

──────────────────────────────────────────────────────────────────────────────
15) Exit status
• 0 = successo, diverso da 0 = errore (0..255).
• In una “lista di comandi”, l’exit status è quello dell’ultimo comando.

Nota sulle espressioni aritmetiche:
• (( ... )) ritorna exit status 0 se l’espressione è “vera” (risultato != 0),
  e 1 se è “falsa” (risultato == 0).

──────────────────────────────────────────────────────────────────────────────
16) Cicli / if + operatori ; || && (Bash)

Idea base: “liste di comandi”
• In bash una condizione non è solo “vero/falso”: è una LISTA di comandi.
• Ogni comando ritorna un exit status: 0 = successo (usato come “vero”), !=0 = fallimento (“falso”).

Operatori più usati
• ;   → separa comandi sulla stessa riga (sequenza):
  cmd1; cmd2; cmd3

• &&  → AND: esegue il comando a destra SOLO se quello a sinistra è riuscito (exit 0):
  mkdir dir && cd dir
  [[ -f file ]] && echo "esiste"

• ||  → OR: esegue il comando a destra SOLO se quello a sinistra è fallito (exit !=0):
  cd dir || exit 1
  [[ -f file ]] || echo "manca"

Combinazioni tipiche (pattern da esame)
• “Se fallisce esci”:
  cmd || exit 1
• “Se ok fai qualcosa”:
  cmd && echo "ok"
• “If corto”:
  [[ cond ]] && fai_qualcosa || fai_altro
  (attenzione: se fai_qualcosa fallisce, parte anche fai_altro)

Cicli
• for var in lista; do ...; done
  - Itera su una lista di parole/elementi (argomenti, glob, array, ecc.)
  Esempi:
    for f in *.txt; do echo "$f"; done
    for a in "$@";  do echo "$a"; done

• for (( expr1; expr2; expr3 )); do ...; done
  - Stile C: init; cond; step (aritmetico)
  Esempio:
    for ((i=0; i<10; i++)); do echo "$i"; done

If (struttura)
• if LISTA_COMANDI; then ... fi
  - Il ramo “then” parte se l’ultima cosa valutata nella lista ha exit status 0.
  - Puoi mettere più comandi nella condizione usando ; && ||.
Esempi:
  if [[ -f "$1" ]] && [[ -r "$1" ]]; then
    echo "ok"
  else
    echo "errore" >&2
  fi

elif / else
• elif è un altro “if” in cascata: viene provato solo se i precedenti sono falsi.

WHILE (cicli)

• while LISTA_COMANDI; do
    corpo
  done
  - Ripete il corpo FINCHÉ la lista di comandi nella condizione ha exit status 0 (successo).
  - Appena la condizione fallisce (exit !=0), il ciclo termina.

Esempi tipici

1) Condizione con confronto
  i=0
  while (( i < 10 )); do
    echo "$i"
    ((i++))
  done

2) Lettura righe da file (forma “da esame”)
  while IFS= read -r riga; do
    echo "$riga"
  done < file.txt

3) Condizione composta con && / ||
  while IFS= read -r riga && [[ -n "$riga" ]]; do
    echo "$riga"
  done < file.txt

4) Loop infinito
  while :; do
    echo "loop"
    break
  done

Nota
• La condizione del while può essere una lista con ; && ||, come negli if.
──────────────────────────────────────────────────────────────────────────────
17) File Descriptor (FD)
• Astrazione per l’accesso a file/stream.
• Ogni processo ha una “tabella dei FD” dei file aperti.
Standard:
  0 = STDIN
  1 = STDOUT
  2 = STDERR
Ereditarietà:
• Un processo figlio eredita una copia dei FD del padre.

Nota pratica:
• In /proc/$$/fd (Linux) trovi i “collegamenti” ai file aperti dal processo della shell.

──────────────────────────────────────────────────────────────────────────────
18) read (lettura da STDIN o da un FD)
• Legge una riga (fino a newline) da input e la assegna a una o più variabili.
• Se passi più variabili, read usa IFS per separare la riga in “campi”.

Comportamento a EOF (fine file):
• Se EOF arriva subito: variabile = "" e read ritorna “fallimento” (exit status != 0).
• Se legge qualche carattere e poi EOF senza newline:
  - la variabile contiene i caratteri letti
  - ma read ritorna comunque exit status != 0

Opzioni utili:
• -r        → non interpreta backslash (consigliato quasi sempre)
• -n N      → legge fino a N caratteri (newline non conta come carattere terminatore)
• -N N      → legge esattamente N caratteri (newline conta come carattere)
• -u FD     → legge da uno specifico file descriptor (FD già aperto)
• -t SEC    → timeout (se supportato/previsto dall’ambiente)

Esempi:
  IFS= read -r linea
  read A B C <<< "alfa beta gamma"
  while IFS= read -r riga; do echo "$riga"; done < file.txt

──────────────────────────────────────────────────────────────────────────────
19) exec: aprire/chiudere file descriptor dalla shell
• L’utente può scegliere il FD oppure farlo assegnare automaticamente.

Aprire (shell corrente):
• sola lettura:
  exec N< file
  exec {FD}< file
• sola scrittura:
  exec N> file
  exec {FD}> file
• append:
  exec N>> file
  exec {FD}>> file
• lettura+scrittura:
  exec N<> file
  exec {FD}<> file

Chiudere:
  exec N>&-
  exec {FD}>&-

Nota:
• Le modifiche fatte con exec “persistono” nella shell corrente finché non chiudi/ripristini.

──────────────────────────────────────────────────────────────────────────────
20) Redirezioni e pipe (I/O)

Metacaratteri principali (promemoria):
  >  >>  <     redirezione I/O
  |            pipe
  <<           here document
  <<<          here string
  &            background

20.1) Redirezioni base
• > file        → STDOUT su file (sovrascrive)
• >> file       → STDOUT su file (append)
• < file        → file su STDIN
• 2> file       → STDERR su file
• &> file       → STDOUT + STDERR su file (sovrascrive)
• 2>&1          → manda STDERR dove punta attualmente STDOUT
• 1>&2          → manda STDOUT dove punta attualmente STDERR
• qualcosa >&2  → manda qualcosa dove punta attualmente STDERR
• N> file       → redirige il FD N su file
• <N file       → usa “file” come input del FD N (forma meno comune)
• /dev/null     → file speciale che scarta tutti i dati scritti e fornisce immediatamente EOF in lettura.
                  Si usa nelle redirezioni per ignorare output o errori, ad esempio comando > /dev/null 2>&1

20.2) Pipe
• cmd1 | cmd2   → collega STDOUT di cmd1 a STDIN di cmd2
• |&            → collega STDOUT+STDERR di cmd1 a STDIN di cmd2 (scorciatoia utile)

20.3) Here string e here document
Here string (una stringa come input):
  read A B C <<< "alfa beta gamma"

Here document (blocco multilinea):
  while read A B C; do echo "$B"; done <<FINE
  uno due tre quattro
  alfa beta gamma
  gatto cane
  FINE

20.4) Redirezione nei processi figli (idea)
• Tra fork ed exec, il figlio può “duplicare” una risorsa (pipe/file) su un FD standard
  (es. 1), sovrascrivendo il collegamento ereditato (es. terminale), prima di eseguire
  il nuovo programma.

──────────────────────────────────────────────────────────────────────────────
21) wc
• Conta righe/parole/byte/caratteri, su STDIN o file.
• Esempi:
  wc -l file.txt     # linee
  wc -w file.txt     # parole
  wc -c file.txt     # byte
(vedi wc --help)

──────────────────────────────────────────────────────────────────────────────
22) Processi, job control, segnali, kill/killall/nohup/disown

22.1) PID e variabili
• $$        → PID della shell corrente
• Attenzione alle subshell: in bash, dentro ( ... ) spesso $$ resta quello della shell “padre”;
  per il PID reale della subshell usa $BASHPID.

22.2) Background/foreground e job control
• Foreground: il processo “controlla” il terminale e blocca la shell fino a fine.
• Background: la shell continua a leggere comandi; il job usa i FD ereditati.

Comandi/azioni:
• comando &     → lancia in background(da mettere dopo il processo)
  - $! contiene il PID dell’ultimo processo lanciato con &
• Ctrl+Z        → sospende (SIGTSTP)
• Ctrl+C        → interrompe (SIGINT)
• bg            → riprende in background un processo sospeso
• fg %n         → porta in foreground il job n (indice mostrato da jobs)
• jobs          → lista numerata dei job (figli di quella shell)
• kill PID      → invia un segnale (default SIGTERM)
• kill %n       → invia al job n

Nota su $!:
• Se lanci un processo con “comando &”, $! viene aggiornato.
• Se metti in background con “bg” un processo già esistente (da Ctrl+Z), $! non viene aggiornato.

22.3) SIGHUP, disown e nohup
• Quando una shell interattiva termina, invia SIGHUP ai suoi job (background o sospesi).
• disown “sgancia” il job dalla shell, evitando il SIGHUP alla chiusura della shell.
  - disown        → sgancia l’ultimo job in background
  - disown -r     → sgancia tutti i job running
  - disown -a     → sgancia running + sospesi
  - disown %jobid → sgancia un job specifico
• nohup comando &  → equivalente pratico di:
    comando &
    disown

22.4) Segnali e kill
• Un segnale è un’interruzione software asincrona inviata a un processo.

Esempi (pid = 7777):
• SIGTERM (default, “gentile”, intercettabile):
  kill 7777
  kill -15 7777
  kill -SIGTERM 7777
• SIGKILL (forzato, non intercettabile):
  kill -9 7777
  kill -SIGKILL 7777
• Altri segnali utili:
  kill -SIGTSTP pid   # come Ctrl+Z
  kill -SIGCONT pid   # riprende (usato da fg/bg)
  kill -SIGINT pid    # come Ctrl+C
• Elenco segnali:
  kill -l

Nota importante:
• Un processo bloccato in I/O (rete) o in sleep può gestire il segnale “in ritardo”
  (solo al termine dell’attesa).

22.5) killall
• Termina (o invia segnali a) processi con un dato nome.
• Può usare anche selezione tramite espressione regolare (opzione -r).
Esempio (regex sui nomi dei processi):
  killall -r 'attendi[[:upper:]]*'
Nota: gli apici singoli impediscono alla bash di interpretare i metacaratteri.

22.6) trap
- trap (catturare segnali / cleanup)
    - serve per dire a bash: "quando arriva un segnale (o quando lo script sta per terminare), esegui questi comandi"
    - utilissimo per:
        - pulire file temporanei (rm)
        - chiudere processi lanciati in background (&)
        - rilasciare lock / ripristinare stato prima di uscire (anche se faccio Ctrl+C)

    - sintassi:
        - trap 'comandi' SIGNAL1 SIGNAL2 ...
        - trap 'comandi' EXIT
            - EXIT non è un segnale "vero": è un evento che scatta quando lo script termina (anche se termina normalmente)

        - trap - SIGNAL
            - resetta il comportamento di default per quel segnale

        - trap '' SIGNAL
            - ignora quel segnale (attenzione: può rendere difficile fermare lo script)

        - trap -p
            - stampa i trap attivi (debug)

    - esempio tipico (cleanup + kill di un processo in background):
        - ./pong.sh &
        - PONGPID=$!            # $! = PID dell'ultimo processo lanciato in background
        - trap 'rm -f ping.txt pong.txt; kill "$PONGPID" 2>/dev/null; exit 0' INT TERM EXIT

        - cosa significa:
            - INT (SIGINT): arriva con Ctrl+C -> esegue cleanup, termina pong, esce
            - TERM (SIGTERM): arriva con "kill PID" -> esegue cleanup, termina pong, esce
            - EXIT: quando lo script sta per terminare -> esegue cleanup finale

    - nota importante:
        - SIGKILL (9) = kill -9 -> NON si può catturare con trap (non è intercettabile)
        - quindi trap funziona per segnali "gestibili" (INT, TERM, ecc.) ma non per KILL

- segnali (richiamo rapido)
    - lista segnali: kill -l

    - SIGINT (2)
        - interruzione da tastiera (Ctrl+C)
        - di default termina il processo, ma posso intercettarlo con trap

    - SIGTERM (15)
        - terminazione "gentile" (default di: kill PID)
        - intercettabile con trap (per fare cleanup prima di uscire)

    - SIGKILL (9)
        - terminazione forzata (kill -9 PID)
        - NON intercettabile, NON ignorabile (trap non può farci nulla)

    - SIGTSTP
        - stop da tastiera (Ctrl+Z)
        - il processo resta "stoppato" (poi: fg / bg)

    - SIGCONT
        - riprende un processo stoppato (usato da fg / bg)

    - SIGHUP
        - "hangup": spesso quando chiudi terminale / sessione
        - si evita con nohup / disown


──────────────────────────────────────────────────────────────────────────────
23) Coreutils (promemoria operativo) — spiegazione “da esame”

Idea generale
• Sono comandi “piccoli” che lavorano su testo tramite pipe/redirezioni.
• Schema tipico: comando_che_produce_testo | filtro1 | filtro2 > output

23.1) sed (stream editor)
• Modifica testo “al volo” riga per riga (non cambia il file, a meno di -i).
• Operazione più comune: s/REGEX/SOSTITUZIONE/ (substitute)
  - senza g: sostituisce solo la prima occorrenza per riga
  - con g: sostituisce tutte le occorrenze per riga
Esempi utili:
  sed 's/togli/metti/' file        # 1ª occorrenza per riga
  sed 's/togli/metti/g' file       # tutte le occorrenze
  sed 's/^.//' file                # elimina 1° char di ogni riga (^ = inizio, . = un char)
  sed 's/.$//' file                # elimina ultimo char di ogni riga ($ = fine)
  sed -E 's/^.{4}//' file          # elimina i primi 4 char (.{4} = 4 caratteri)
• In-place (modifica il file): sed -i '...' file  (attenzione: è distruttivo)

23.2) head / tail
• Servono per prendere “pezzi” di file (righe).
  head -n 20 file   # prime 20 righe
  tail -n 20 file   # ultime 20 righe
  tail -f file      # segue un file che cresce (log): continua a mostrare nuove righe

23.3) tee
• Duplica lo stream: quello che arriva in input lo stampa a video e lo scrive anche su file.
  comando | tee output.txt
• Utile quando vuoi “vedere” l’output ma anche salvarlo, senza perdere la pipe.

23.4) cut
• Estrae “colonne” in due modi principali:
  1) Per delimitatore (-d) e campo (-f): (campo = colonna)
     cut -d ':' -f 1 /etc/passwd      # prende il 1° campo separato da :
  2) Per posizioni di caratteri (-c):
     cut -c 1-5 file                  # caratteri da 1 a 5
     cut -c 5- file                   # dal 5° fino alla fine
     cut -c -5 file                   # dai primi 5
• Nota: -f lavora su “campi” separati da un delimitatore, -c lavora su “posizioni” fisse.

23.5) grep
• Cerca righe che matchano un pattern.
  grep "parola" file
• Opzioni tipiche:
  grep -n "pat" file   # mostra numero di riga
  grep -i "pat" file   # case-insensitive
  grep -v "pat" file   # righe che NON matchano
  grep -E "re" file    # regex estese (ERE)
  grep -o "pat" file   # stampa solo i match (utile per contare con wc -l)
• Per contare righe matchate: grep -c "pat" file

23.6) tr (translate / delete characters)
• Trasforma caratteri (non parole). Lavora da stdin a stdout.
• Traduzione (sostituisce caratteri):
  echo "ciao" | tr 'ao' 'A0'          # a->A, o->0
  tr '[:lower:]' '[:upper:]' < file  # minuscole->maiuscole
• Cancellazione:
  echo "a1b2c3" | tr -d '0-9'         # elimina cifre
  echo "a1b2c3" | tr -cd '0-9\n'      # tiene solo cifre (e newline)
• Compressione ripetizioni:
  echo "a   b     c" | tr -s ' '      # comprime spazi multipli
• Note rapide:
  - SET può essere 'a-z', '0-9' o classi '[:digit:]', '[:space:]', ecc.
  - tr non capisce “regex”, solo insiemi di caratteri.

──────────────────────────────────────────────────────────────────────────────
24) Parameter expansion — riassunto operativo (stringhe)

Rimozione pattern:
• ${VAR%%pattern}   rimuove il più lungo suffisso che matcha pattern
• ${VAR%pattern}    rimuove il più corto suffisso che matcha pattern
• ${VAR##pattern}   rimuove il più lungo prefisso che matcha pattern
• ${VAR#pattern}    rimuove il più corto prefisso che matcha pattern

Sostituzione:
• ${VAR/pat/str}    sostituisce la prima occorrenza
• ${VAR//pat/str}   sostituisce tutte le occorrenze
• ${VAR#/pat/str}   sostituisce solo se matcha all’inizio
• ${VAR/%pat/str}   sostituisce solo se matcha alla fine

Sottostringhe e lunghezza:
• ${#VAR}                 lunghezza
• ${VAR:offset}           sottostringa da offset
• ${VAR:offset:length}    sottostringa di lunghezza “length”

Variabili per prefisso:
• ${!prefix*}   elenco dei nomi di variabili che iniziano con “prefix”

──────────────────────────────────────────────────────────────────────────────
25) Scaricamento con wget

25.1) wget
• Installa da un determinato url
  wget [url]
  (vedi anche wget --help)

──────────────────────────────────────────────────────────────────────────────
26) Tar

26.1) tar xvzf file per estrarre da archivio

──────────────────────────────────────────────────────────────────────────────
28) Regex
- REGEX (espressioni regolari) - riassunto da esame

    - Una REGEX è un linguaggio per descrivere pattern di testo (es: “righe che iniziano con…”, “numeri interi”, ecc.)
      Serve per cercare/filtrare/sostituire testo con comandi tipo grep / sed / awk e anche in bash ([[ ... =~ ... ]]).

--------------------------------------------------------------------------------
28.1) Famiglie di regex (in Linux non esiste “una sola regex”)

    - BRE (Basic Regular Expressions)
        - usate da: grep (senza -E), sed (spesso)
        - alcuni operatori NON funzionano “diretti” (devono essere escapati):
            +  ?  |  ( )
          es: in BRE per “una o più volte” devi scrivere \+ e per i gruppi \( \)

    - ERE (Extended Regular Expressions)
        - usate da: grep -E (o egrep), awk, bash [[ =~ ]] (in pratica “simile a ERE”)
        - qui funzionano diretti: + ? | ( )

    - PCRE (Perl Compatible)
        - usate da: grep -P (se disponibile)
        - supporta cose avanzate (lookahead/lookbehind, \d, ecc.)

    - Nota: grep -F NON usa regex (match letterale fisso), spesso è la scelta migliore per cercare caratteri speciali
      (es: cercare * senza impazzire con gli escape).

--------------------------------------------------------------------------------
28.2) Mattoni fondamentali (pattern base)

    - Caratteri normali:
        abc            -> matcha letteralmente “abc”

    - Punto (jolly):
        .              -> matcha 1 carattere qualunque (di solito escluso newline)

    - Classi di caratteri (tra []):
        [abc]          -> un carattere tra a, b, c
        [a-z]          -> una lettera minuscola
        [0-9]          -> una cifra
        [^0-9]         -> NON una cifra (negazione dentro le [])

    - Classi POSIX (utili e portabili, dentro []):
        [[:digit:]]    -> cifre
        [[:alpha:]]    -> lettere
        [[:alnum:]]    -> lettere o cifre
        [[:space:]]    -> spazi bianchi (spazio, tab, newline…)
        [[:lower:]]    -> minuscole
        [[:upper:]]    -> maiuscole
        [[:punct:]]    -> punteggiatura

--------------------------------------------------------------------------------
28.3) Quantificatori (ripetizioni)

    (in ERE/PCRE sono diretti; in BRE spesso vanno escapati)

    - *   -> 0 o più volte
        a*         matcha: "" , "a" , "aaaa"

    - +   -> 1 o più volte
        a+         matcha: "a" , "aaaa" (non stringa vuota)

    - ?   -> 0 o 1 volta (opzionale)
        colou?r    matcha "color" e "colour"

    - {n}    -> esattamente n volte
        [0-9]{4}   matcha 4 cifre

    - {n,}   -> almeno n volte
        a{2,}      matcha "aa", "aaa", ...

    - {n,m}  -> da n a m volte
        [0-9]{2,4}

--------------------------------------------------------------------------------
28.4) Ancore (posizione nella riga/stringa)

    - ^   -> inizio riga/stringa
    - $   -> fine riga/stringa

    Esempio:
        ^abc$   matcha SOLO la riga/stringa “abc” e basta

--------------------------------------------------------------------------------
28.5) Alternativa e raggruppamento

    - |        -> oppure (alternativa)
        cat|dog

    - ( ... )  -> gruppo (in ERE/PCRE; in BRE spesso \( ... \))
        (ab)+   ripete la sequenza “ab” una o più volte

--------------------------------------------------------------------------------
28.6) Escape (cercare caratteri speciali letterali)

    - Alcuni caratteri hanno significato speciale in regex: . * + ? [ ] ( ) { } ^ $ | \
      Se vuoi cercarli letterali, fai escape con \

    esempi:
        \.   -> punto letterale
        \*   -> asterisco letterale
        \[   -> parentesi quadra letterale

    alternativa semplice (consigliata quando possibile):
        grep -F '*' file    -> cerca l’asterisco come testo normale, senza regex

--------------------------------------------------------------------------------
28.7) Backreference (riferimento a gruppi) - spesso in ERE/PCRE, dipende dal tool

    - idea: catturi un gruppo e lo riusi
      Esempio:
        ^(ab)\1$    matcha “abab”
      (in alcuni tool serve sintassi diversa a seconda di BRE/ERE)

--------------------------------------------------------------------------------
28.8) Greedy vs Lazy

    - In ERE classico i quantificatori sono di solito “greedy” (prendono il più possibile).
    - In PCRE esiste anche “lazy” (minimo possibile), es: .*?
      Nota: .*? non è standard ERE.

--------------------------------------------------------------------------------
28.9) Regex nei comandi (uso pratico)

    - grep:
        grep 'REGEX' file      -> BRE
        grep -E 'REGEX' file   -> ERE
        grep -P 'REGEX' file   -> PCRE (se disponibile)
        grep -F 'TESTO' file   -> match fisso (NO regex)

      opzioni utili:
        -q  (silenzioso, usa solo exit status)
        -n  (mostra numero di riga)
        -c  (conta righe matchate)
        -r  (ricorsivo)
        -w  (parola intera, utile ma non sempre perfetto)

    - sed:
        sed 's/REGEX/REPL/' file
        sed -E 's/(ab)+/X/' file   (se supportato, abilita ERE)

    - awk (ERE):
        awk '/REGEX/ {print $0}' file
        awk '$1 ~ /^abc/ {print $2}' file

    - bash ([[ ... =~ ... ]]) (match regex in bash):
        if [[ "$x" =~ REGEX ]]; then ...
        Nota: funziona con [[ ... ]] (non con [ ... ])

--------------------------------------------------------------------------------
28.10) Pattern pronti (mini-esempi utili)

    - Intero (anche negativo):
        ^-?[0-9]+$

    - Intero con segno + o -:
        ^[+-]?[0-9]+$

    - Riga che contiene almeno un asterisco:
        \*
      oppure: grep -F '*'

    - “identificatore” tipo variabile (lettere/cifre/_):
        ^[[:alnum:]_]+$

    - Email semplice (non perfetta):
        ^[^@[:space:]]+@[^@[:space:]]+\.[^@[:space:]]+$

----------------------------------------------------------------------------------
29) Dettagli while
WHILE / READ con condizioni multiple (&& / ||) + file descriptor (-u)

Idea chiave
• In bash, la “condizione” di while/until può essere una LISTA di comandi.
• Il ciclo continua finché l’ULTIMO comando della lista termina con exit status 0.
• Puoi concatenare read + test [[...]] + aritmetica ((...)) con && / ||.

29.1) read + condizioni extra sulla riga/campi
• Continua solo se read riesce (non EOF) E la condizione è vera:
  while IFS= read -r line && [[ -n "$line" ]]; do
    echo "$line"
  done < file.txt

29.2) read da file descriptor (-u) con condizioni (stile esame)
• Apro FD, leggo da lì, chiudo FD:
  exec {FD}< file.txt
  while IFS= read -r -u "$FD" a1 a2 a3 && [[ -n "$a1" ]] && [[ "$a1" != "#"* ]]; do
    echo "campi: $a1 | $a2 | $a3"
  done
  exec {FD}<&-

29.3) Due read nella condizione (es. coppie di righe)
• Itera a coppie: termina se il secondo read fallisce:
  while IFS= read -r r1 && IFS= read -r r2; do
    echo "$r1 / $r2"
  done < file.txt

29.4) Due file in parallelo (due FD) + stop se manca un campo
  exec {F1}< f1.txt
  exec {F2}< f2.txt
  while IFS= read -r -u "$F1" a1 a2 a3 a4 \
     && IFS= read -r -u "$F2" b1 b2 b3 b4 \
     && [[ -n "$a4" && -n "$b4" ]]; do
    echo "$a1 $b1 $a2 $b2 $a3 $b3 $a4 $b4"
  done
  exec {F1}<&-; exec {F2}<&-

29.5) read + limite numerico (massimo N righe)
  i=0
  while IFS= read -r line && (( i < 4 )); do
    echo "$line"
    ((i++))
  done < file.txt

29.6) Alternativa: condizione semplice e filtri nel corpo (continue/break)
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    [[ "$line" != "#"* ]] || continue
    echo "$line"
  done < file.txt

Nota importante (pipe + while)
• “cmd | while read ...” spesso gira in subshell → variabili modificate dentro possono NON uscire.
• Se devi mantenere variabili, preferisci:
  while IFS= read -r x; do ...; done < <(cmd)

